<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ê–∫—Ç –≤–æ–∑–≤—Ä–∞—Ç–∞ - –§–æ—Ç–æ (–æ—Ç–ø—Ä–∞–≤–∫–∞ –∞–¥–º–∏–Ω—É)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: #000;
      color: white;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #videoContainer {
      position: relative;
      width: 100%;
      flex: 1;
      overflow: hidden;
      border-radius: 12px;
      background: #111;
    }
    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #canvas { display: none; }
    #controls {
      margin-top: 16px;
      display: flex;
      gap: 12px;
    }
    button {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
    }
    #captureBtn {
      background: #ff3b30;
      color: white;
    }
    #sendBtn {
      background: #34c759;
      color: white;
      display: none;
    }
    #counter {
      text-align: center;
      margin: 12px 0;
      font-size: 18px;
    }
    .error {
      color: #ff3b30;
      text-align: center;
      padding: 20px;
    }
    #status { text-align:center; margin-top:10px; font-size:14px; }
    #advanced { margin-top:12px; font-size:13px; color:#ccc }
    input, label { font-size:13px }
  </style>
</head>
<body>
  <div id="videoContainer">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <div id="counter">–°–¥–µ–ª–∞–Ω–æ —Ñ–æ—Ç–æ: <span id="count">0</span> / 6</div>

  <div id="controls">
    <button id="captureBtn">üì∏ –°–¥–µ–ª–∞—Ç—å —Ñ–æ—Ç–æ</button>
    <button id="flashBtn" title="–í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –≤—Å–ø—ã—à–∫—É">‚ö° –í—Å–ø—ã—à–∫–∞: –≤—ã–∫–ª</button>
    <button id="sendBtn">üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å—ë</button>
  </div>

  <div id="status"></div>

  <!-- Advanced options: –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º–∏. –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Å–ø–æ—Å–æ–±: –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω—ã–π endpoint –∏ —É–∫–∞–∑–∞—Ç—å –µ–≥–æ URL –Ω–∏–∂–µ. -->
  <div id="advanced">
    <details>
      <summary>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–Ω–∞–∂–º–∏—Ç–µ —á—Ç–æ–±—ã —Ä–∞—Å–∫—Ä—ã—Ç—å)</summary>
      <p>–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Å–µ—Ä–≤–µ—Ä–Ω—ã–π endpoint, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–º–µ—Ç —Ñ–æ—Ç–æ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç –∏—Ö –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –æ—Ç –∏–º–µ–Ω–∏ –±–æ—Ç–∞ (–±–µ–∑ –ø–µ—Ä–µ–¥–∞—á–∏ —Ç–æ–∫–µ–Ω–∞ –≤ –∫–ª–∏–µ–Ω—Ç–µ).</p>
      <p>
        1) –£–∫–∞–∂–∏—Ç–µ URL –≤–∞—à–µ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: <code>https://example.com/upload_photos</code>.
      </p>
      <p>
        2) –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –∫–ª–∏–µ–Ω—Ç–∞ (–ù–ï –†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø ‚Äî —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –±—É–¥–µ—Ç –≤–∏–¥–µ–Ω –≤ –∫–æ–¥–µ/–∫–ª–∏–µ–Ω—Ç–µ), —Ä–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ "Direct to Telegram" –∏ —É–∫–∞–∂–∏—Ç–µ —Ç–æ–∫–µ–Ω –∏ ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.
      </p>

      <div>
        <label>Server upload URL: <input id="serverUrl" type="text" value="https://hallowed-incantation-4jppv679xv943qw4j-3000.app.github.dev/upload_photos" placeholder="https://your.server/upload_photos" style="width:100%" /></label>
        <p style="color:#bbb; margin-top:6px;">–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–Ω–µ—à–Ω–∏–π –∞–¥—Ä–µ—Å, —É–∫–∞–∑–∞–Ω–Ω—ã–π –≤–∞–º–∏. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ HTTPS –∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç POST /upload_photos.</p>
      </div>
      <hr>
      <details>
        <summary>Direct to Telegram (–Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–∞)</summary>
        <div>
          <label>Bot token: <input id="botToken" type="text" placeholder="123456:ABC-DEF..." style="width:100%" /></label>
        </div>
        <div>
          <label>Admin chat IDs (comma-separated): <input id="adminIds" type="text" placeholder="123456789,987654321" style="width:100%" /></label>
        </div>
      </details>

    </details>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // ==================================================================================
    // –≠—Ç–æ—Ç —Ñ–∞–π–ª –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π foto.html (—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ —Å—ä—ë–º–∫–∏).
    // –ò–∑–º–µ–Ω–µ–Ω–∏—è: –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å—ë" –¥–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.
    // –ü–æ–¥—Ö–æ–¥—ã:
    //  - –†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ô: —É–∫–∞–∂–∏—Ç–µ SERVER_UPLOAD_URL ‚Äî –∫–ª–∏–µ–Ω—Ç –∑–∞–≥—Ä—É–∑–∏—Ç —Ñ–æ—Ç–æ –Ω–∞ –≤–∞—à —Å–µ—Ä–≤–µ—Ä (POST multipart/form-data),
    //    —Å–µ—Ä–≤–µ—Ä —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç —Ñ–æ—Ç–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º —Å –ø–æ–º–æ—â—å—é Bot API (–±–µ–∑ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è —Ç–æ–∫–µ–Ω–∞ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ).
    //  - –û–ü–¶–ò–Ø (–Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ): —É–∫–∞–∂–∏—Ç–µ BOT_TOKEN –∏ ADMIN IDs –Ω–∏–∂–µ ‚Äî –∫–ª–∏–µ–Ω—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç —Ñ–æ—Ç–æ –Ω–∞–ø—Ä—è–º—É—é –≤ Telegram Bot API.
    // ==================================================================================

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const captureBtn = document.getElementById('captureBtn');
    const sendBtn = document.getElementById('sendBtn');
    const countEl = document.getElementById('count');
    const statusEl = document.getElementById('status');

    const serverUrlInput = document.getElementById('serverUrl');
    const botTokenInput = document.getElementById('botToken');
    const adminIdsInput = document.getElementById('adminIds');

    let photos = [];
    let photoCount = 0;
    const MAX_PHOTOS = 6;

    const tg = window.Telegram ? window.Telegram.WebApp : null;
    if (tg) {
      try { tg.ready(); tg.expand(); } catch(e) { console.warn('tg init', e); }
    }

    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        // Save the video track so we can control torch (flash) when supported
        window._videoTrack = stream.getVideoTracks && stream.getVideoTracks()[0];
        if (window._videoTrack) {
          try {
            const caps = window._videoTrack.getCapabilities && window._videoTrack.getCapabilities();
            if (caps && caps.torch) {
              statusEl.textContent = '–í—Å–ø—ã—à–∫–∞: –¥–æ—Å—Ç—É–ø–Ω–∞';
            } else {
              // some devices may support ImageCapture flash modes
              statusEl.textContent = '–í—Å–ø—ã—à–∫–∞: –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º';
            }
          } catch (e) {
            console.warn('getCapabilities failed', e);
          }
        }
      })
      .catch(err => {
        document.body.innerHTML = `<div class="error">‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ.<br>–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Telegram.</div>`;
        console.error("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã:", err);
      });

    captureBtn.onclick = () => {
      if (photoCount >= MAX_PHOTOS) return;

      canvas.width = video.videoWidth || 1280;
      canvas.height = video.videoHeight || 720;

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∂–∞—Ç—ã–π JPEG, —á—Ç–æ–±—ã —É–º–µ–Ω—å—à–∏—Ç—å —Ä–∞–∑–º–µ—Ä
      const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
      photos.push(dataUrl);
      photoCount++;

      countEl.textContent = photoCount;

      if (photoCount === MAX_PHOTOS) {
        captureBtn.disabled = true;
        sendBtn.style.display = 'block';
      }

      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–∞–∫–∂–µ –µ—Å–ª–∏ —Å–¥–µ–ª–∞–ª–∏ —Ö–æ—Ç—è –±—ã 1 —Ñ–æ—Ç–æ
      if (photoCount > 0) sendBtn.style.display = 'block';
    };

    // Utility: convert dataURL to Blob
    function dataURLToBlob(dataURL) {
      const parts = dataURL.split(',');
      const mime = parts[0].match(/:(.*?);/)[1];
      const binary = atob(parts[1]);
      const array = [];
      for (let i = 0; i < binary.length; i++) array.push(binary.charCodeAt(i));
      return new Blob([new Uint8Array(array)], { type: mime });
    }

    // Flash / torch control
    const flashBtn = document.getElementById('flashBtn');
    let flashEnabled = false;

    function updateFlashButton() {
      flashBtn.textContent = flashEnabled ? '‚ö° –í—Å–ø—ã—à–∫–∞: –≤–∫–ª' : '‚ö° –í—Å–ø—ã—à–∫–∞: –≤—ã–∫–ª';
      flashBtn.style.background = flashEnabled ? '#ffd60a' : '#444';
      flashBtn.style.color = flashEnabled ? '#000' : '#fff';
    }

    async function setTorch(on) {
      const track = window._videoTrack;
      if (!track) {
        statusEl.textContent = '–í—Å–ø—ã—à–∫–∞: –∫–∞–º–µ—Ä–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞';
        return false;
      }
      const caps = track.getCapabilities && track.getCapabilities();
      if (caps && caps.torch) {
        try {
          await track.applyConstraints({ advanced: [{ torch: on }] });
          return true;
        } catch (err) {
          console.warn('applyConstraints torch error', err);
          return false;
        }
      }

      // Fallback: try ImageCapture APIs to request a flash when taking a photo (limited support)
      try {
        if (window.ImageCapture) {
          const ic = new ImageCapture(track);
          const photoCaps = await ic.getPhotoCapabilities().catch(() => null);
          if (photoCaps && photoCaps.fillLightMode && photoCaps.fillLightMode.length) {
            // we cannot enable continuous torch via ImageCapture; inform user
            statusEl.textContent = '–í—Å–ø—ã—à–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—ä—ë–º–∫–µ (–±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –ø—Ä–∏ capture)';
            return true;
          }
        }
      } catch (e) {
        console.warn('ImageCapture check failed', e);
      }

      statusEl.textContent = '–í—Å–ø—ã—à–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ';
      return false;
    }

    flashBtn.addEventListener('click', async () => {
      // toggle
      const desired = !flashEnabled;
      const ok = await setTorch(desired);
      if (ok) {
        flashEnabled = desired;
        updateFlashButton();
      } else {
        // show unsupported message briefly
        statusEl.textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ–Ω–∏—Ç—å —Ä–µ–∂–∏–º –≤—Å–ø—ã—à–∫–∏';
        setTimeout(() => { statusEl.textContent = ''; }, 2500);
      }
    });

    // initialize flash button UI
    updateFlashButton();

    // Send photos to server endpoint (recommended)
    async function uploadToServer(url) {
      if (!url) throw new Error('Server URL not provided');
      statusEl.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...';

      const form = new FormData();
      form.append('photoCount', photos.length);
      // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª—ã: photo0, photo1, ...
      photos.forEach((d, idx) => {
        const blob = dataURLToBlob(d);
        form.append('photo' + idx, blob, `photo_${idx}.jpg`);
      });

      // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –º–µ—Ç–∞-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é, –Ω–∞–ø—Ä–∏–º–µ—Ä id –∞—Ä–µ–Ω–¥—ã
      // form.append('rental_id', '...');

      const resp = await fetch(url, {
        method: 'POST',
        body: form
      });

      if (!resp.ok) {
        const text = await resp.text();
        throw new Error('Server error: ' + resp.status + ' ' + text);
      }

      const result = await resp.json().catch(() => null);
      return result;
    }

    // Direct send to Telegram Bot API from client (insecure ‚Äî token exposed in client). Use only for testing.
    async function sendDirectToTelegram(botToken, adminIds) {
      if (!botToken) throw new Error('Bot token not provided');
      if (!adminIds || adminIds.length === 0) throw new Error('Admin IDs not provided');

      statusEl.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞–ø—Ä—è–º—É—é –≤ Telegram (–ø–æ–¥ –∫–∞–ø–æ—Ç–æ–º Bot API)...';

      // For each admin, send photos one by one (could be optimized with sendMediaGroup server-side)
      for (const adminId of adminIds) {
        for (let i = 0; i < photos.length; i++) {
          const blob = dataURLToBlob(photos[i]);
          const fd = new FormData();
          fd.append('chat_id', adminId.trim());
          fd.append('photo', blob, `photo_${i}.jpg`);
          fd.append('caption', `–§–æ—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ (${i+1}/${photos.length})`);

          const res = await fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, {
            method: 'POST',
            body: fd
          });

          if (!res.ok) {
            const text = await res.text();
            throw new Error('Telegram API error: ' + res.status + ' ' + text);
          }
        }
      }

      return true;
    }

    // Fallback: send small metadata to bot via tg.sendData (may be too large for images)
    function sendViaWebAppData() {
      if (!tg) throw new Error('Telegram WebApp not available');
      statusEl.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ –±–æ—Ç —á–µ—Ä–µ–∑ WebApp (–±–µ–∑ —Ñ–∞–π–ª–æ–≤)...';
      const payload = {
        action: "return_photos",
        photoCount: photoCount,
        // –ù–ï –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∞–º–∏ –±–æ–ª—å—à–∏–µ dataURLs –∑–¥–µ—Å—å, —Ç–æ–ª—å–∫–æ –º–∏–Ω–∏–∞—Ç—é—Ä—ã –∏–ª–∏ –ø—É—Å—Ç–æ–π –º–∞—Ä–∫–µ—Ä
        // –µ—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å thumbnails, –¥–æ–±–∞–≤—å—Ç–µ —É–º–µ–Ω—å—à–µ–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ (–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ)
        note: 'photos_ready_on_client'
      };
      tg.sendData(JSON.stringify(payload));
      return true;
    }

    sendBtn.onclick = async () => {
      statusEl.textContent = '';
      sendBtn.disabled = true;
      captureBtn.disabled = true;

      const serverUrl = (serverUrlInput && serverUrlInput.value && serverUrlInput.value.trim()) || null;
      const botToken = (botTokenInput && botTokenInput.value && botTokenInput.value.trim()) || null;
      const adminIdsRaw = (adminIdsInput && adminIdsInput.value && adminIdsInput.value.trim()) || null;
      const adminIds = adminIdsRaw ? adminIdsRaw.split(',').map(s => s.trim()).filter(Boolean) : [];

      try {
        if (serverUrl) {
          // Recommended flow: upload to your server; server will forward to admins
          const res = await uploadToServer(serverUrl);
          statusEl.textContent = '–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä.';
          // Optionally inform the bot via WebApp that upload finished
          if (tg) {
            try { tg.sendData(JSON.stringify({ action: 'uploaded_to_server', result: res })); } catch(e) { console.warn(e); }
          }
        } else if (botToken && adminIds.length > 0) {
          // Direct (insecure) sending from client to Telegram
          await sendDirectToTelegram(botToken, adminIds);
          statusEl.textContent = '–§–æ—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –Ω–∞–ø—Ä—è–º—É—é.';
          if (tg) { try { tg.sendData(JSON.stringify({ action: 'sent_direct'})); } catch(e){} }
        } else if (tg) {
          // Fallback: notify bot to request files another way (e.g., ask user to upload or use server)
          sendViaWebAppData();
          statusEl.textContent = '–î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ –±–æ—Ç (–±–µ–∑ —Ñ–∞–π–ª–æ–≤). –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –ø—Ä–∏—ë–º–∞ —Ñ–æ—Ç–æ.';
        } else {
          throw new Error('–ù–µ—Ç —Å–ø–æ—Å–æ–±–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ: —É–∫–∞–∂–∏—Ç–µ Server URL –∏–ª–∏ Bot Token + Admin IDs.');
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ: ' + (err.message || err);
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ: ' + (err.message || err));
      } finally {
        sendBtn.disabled = false;
        captureBtn.disabled = false;
        // Optionally close webapp
        try { if (tg) tg.close(); } catch(e){}
      }
    };

  </script>
</body>
</html>
